//The Neural Database - Header file definitions
//(c) Copyright 2024 Gary J. Lassiter. All Rights Reserved.

#include <stdio.h>	// I/O functions
#include <time.h>
#include <stdlib.h>	// memory allocation
#include <string.h>	// string manipulation functionms
#include <ctype.h>	// change character case lower/upper
#include <direct.h>	// MakeDirectory function (_mkdir)
#include <omp.h>	// Open MultiProcessing

//If your system has more than this many threads available, change this value and recompile
//OpenMP is used in mpCombineBound(), mpCreateImageNdbs(), and mpRecognizeIMAGE()
#define MAX_THREADS 128


#define INQUIRY_LENGTH 90 //Many temporary arrays use this

#define TOTAL_ALLOWED_RESULTS 10 //Maximum number of multiple results
#define FILE_LINE_LENGTH 1024 //Maximum length of a line in a file

//MNIST image parameters
//The longest image in mnist_train.txt is 2235 bytes
//The longest image in mnist_test.txt is 2139 bytes
#define IMAGE_LENGTH 2304 //2048 + 256
#define MAX_IMAGE_SIZE 28	//square image 28x28
#define NUMBER_OF_IMAGE_RNS 10 //image recognition using 10 RNs


//Recognition Thresholds - these are used to reduce the number of SCU competitors
//To be recognized, an ON needs at least this percentage/100 of RNs in its Bound Section
#define HIT_THRESHOLD 0.61 //Choosen because 0.62 is also OK, but 0.63 creates lots of errors

//To be recognized, an ON must have less than this percentage/100 of RN positional errors
#define ANOMALY_THRESHOLD 0.39

//To be a potential solution, or at least part of one, an ON's PER value (its %recognition)
//must be greater than or equal to this value.
#define PER_1_THRESHOLD 80 //If more than 500 competitors
#define PER_2_THRESHOLD 85 //If more than 1000 competitors
#define PER_3_THRESHOLD 90 //If more than 3000 competitors

//If an enveloping ON has a %recognition exceeding this value, it can remove the enveloped ON
#define ENVELOPMENT_THRESHOLD 75

//After boundaries have been retracted due to a conflict with a more powerful
//ON, the weaker ON can live on if it's %recognition exceeds this threshold
#define RETRACT_BOUNDARY_THRESHOLD 60

//To be a potential solution, or at least part of one, an ON's Composite Score times
//the length of its Bound Section must exceed this value
#define WEAK_ON_THRESHOLD 0.035

//In starting a branch, an Unused ON must have a %recognition exceeding this value
#define UNUSED_THRESHOLD 75

//It's possible for part of the image of a digit (a 'panel') to recognize multiple digits, especially
//a 'blank' corner panel. Many different images have blank corner panels. These multiple possibilities
//are stored in the database as the ON's Surrogate. To contribute to the final interpretation of the
//image, the total number of digits listed in a Surrogate must be less than this threshold.
#define IMAGE_AMBIGUITY_THRESHOLD 8



//Image RN Thresholds...
//CS is a measure of how Curvy or Straight the image is.
#define IMAGE_RN_CS_THRESHOLD 75 //About half way between the values generated by Curvy()

//Is the image Fat, Slim, or in-between? Used in ImageShape()
#define IMAGE_RN_SLANT_THRESHOLD 0.1
#define IMAGE_RN_FAT_THRESHOLD 0.8
#define IMAGE_RN_SLIM_THRESHOLD 0.4

//Where are the most pixels: upper third, lower third, right third, left third?
#define	IMAGE_RN_WEIGHT_UPPER_THRESHOLD 0.625 //Used in GetImageWeights()
#define	IMAGE_RN_WEIGHT_LOWER_THRESHOLD 0.375

//Where is the longest row of pixels: upper third or lower third?
#define	IMAGE_RN_LONGEST_ROW_UPPER_THRESHOLD 0.67 //Used in GetLongestRow()
#define	IMAGE_RN_LONGEST_ROW_LOWER_THRESHOLD 0.34


//Initial number of records per allocated memory blocks, and the expansion factor
#define	RN_RECORDS 100
#define	BR_RECORDS 500
#define	T_RECORDS 100
#define NC_RECORDS 1024
#define	R_RECORDS 500
#define	IMAGE_RN_RECORDS 100

//These initial 'high' values for records-per-memory-block were selected to
//avoid calls to realloc() while running long text queries from the Test
//Library on Ndb #12 (96,000+ words)
#define	BL_RECORDS 4000000
#define	BH_RECORDS 100000
#define	C_RECORDS 300000 //For each(!) of the threads
#define	D_RECORDS 40000
#define	E_RECORDS 4000


typedef struct { //SCU spike train On/Off switches
	int SpaceB;
	int Anomaly;
	int Rec;
	int MinPR;
	int Bound;
	int UnCount;
	int MisLead;
} SCUswitches;

typedef struct { //ON data
	char ON[INQUIRY_LENGTH+1]; //Output Neuron
	//	For TEXT, this would be the word itself
	//	For Images, this would be the Training Set Record Number
	//
	int Len; //Length of ON
	int RL[INQUIRY_LENGTH+1]; //Recognition List
	char SUR[INQUIRY_LENGTH+1]; //Surrogate: For images, storage for the digit, or digits if the image is ambiguous
	char ACT[INQUIRY_LENGTH+1]; //Action to be executed
	//
} NdbON;

typedef struct {
	char RN[INQUIRY_LENGTH+1]; //TEXT and CENTRAL RNs are always characters
} NdbRN;

typedef struct {
	int RN; //IMAGE_28X28 RNs are always numeric
} NdbImageRN;

typedef struct { //The connection from an RN to its position in the ON's Recognition List
	int RNcode;
	int Pos;
	long ONcode;
} NdbRNtoON;

typedef struct {		//The memory-resident Neural Database (Ndb)
	int ID;				//The number N assigned to this database
	int RNcount;
	int RNblocks;
	NdbRN *pRN;			//Memory assigned to char RNs (TEXT Ndbs)
	NdbImageRN *pIRN;	//Memory assigned to int RNs (IMAGE Ndbs)
	long ONcount;
	NdbON *pON;			//Memory assigned to ONs
	long ConnectCount;
	NdbRNtoON *pRNtoON;	//Memory assigned to RN-->ON connections
	char Type[20];		//"TEXT" or "CENTRAL" or "IMAGE_28X28"
} NdbData;


//SCU structures
typedef struct { // The Recognition List RNs that are found in the Input Stream
	int RNcode;
} HitList;

typedef struct { //The 'order' in which RNs are found in a competitor
	int dpos;
	int qpos;
	int rn;
} ORDER;

typedef struct { //SCU Competitor dataset
	int B; //Begin Boundary;
	int E; //End Boundary
	long ONcode;
	int RLhit[INQUIRY_LENGTH+1]; // ON's Recognition List hits: ...m[i].RLhit[dpos] = 0
	int nrec; //number of RN hits (length of RNs in m[i].order)
	ORDER order[INQUIRY_LENGTH+1]; // ON hits in order of appearance in the Input Stream
	int PER; //%recognition
	int QUAL; //quality
	int cntA; //number of positional anomalies
} MEMBER;

typedef struct { //SCU Competitor data
	int Mcount; //number of ONs making up this single competitor
	int Score;
	int spaceB;
	int anomaly;
	int rec;
	int minpr;
	int bound;
	int uncount;
	int mislead;
	int SpaceClaim[INQUIRY_LENGTH+1];
	MEMBER m[INQUIRY_LENGTH+1];
} COMP;

typedef struct { //Head of a linked list of initial Bound Sections (ONs)
	long First;
	long Last;
	long ONcode;
} BH; 

typedef struct { //Member of the linked list of initial Bound Sections, defined by specific locations in the Input Stream
	long Next;
	long Prev;
	int B; //Begin Boundary;
	int E; //End Boundary
	int qpos; //position of the RN in the Input Stream
	int dpos; //position of the RN in the ON's Recognition List
	int Skip; //During processing, if this record has been seen before, then Skip=1
} BL; 

typedef struct { //Array of 'combined' Bound Sections derived from the initial Bound Sections in BL[]
	int B; //Begin Boundary;
	int E; //End Boundary
	long ONcode;
	int qpos; //position of the RN in the Input Stream
	int dpos; //position of the RN in the ON's Recognition List
	int Skip; //During processing, if this record has been seen before, then Skip=1
} BC;

typedef struct { //Array of Bound Sections that survive the Hit Threshold
	int BB; //Actual (qpos) Begin Boundary of the Bound Section in the Input Stream
	int EB; // ditto for End Boundary
	long ONcode;
	int is[INQUIRY_LENGTH+1]; // is[qpos] = 0 or dpos; locations in the Input Stream with associated Recognition List positions
	int RNhits; // number of RN hits
	int cntA; //count of positional anomalies
} D; 

typedef struct { //Array of Bound Sections that survive the Anomaly Threshold
	int B; //Begin Boundary;
	int E; //End Boundary
	long ONcode;
	int cntA; //count of anomalies
} E;

typedef struct { //Initial Results array constructed from E[]
	int B; //Begin Boundary
	int E; //End Boundary
	int ONcode;
	int Score; //SCU score
	int PER; //%recognition
	int QUAL; //Quality
	int cntA; //Anomaly count
	int ALL; //0 or 1, set to 1 if ALL the RNs in the ON's Recognition List are in dpos[].
	int qpos[INQUIRY_LENGTH+1]; //positions 'hit' in the Input Stream
	int rn[INQUIRY_LENGTH+1]; //the RNs in order of being 'hit'
	int dpos[INQUIRY_LENGTH+1]; //positions 'hit' in the ON's Recognition List
	float C; //Composite Score
	int InBranch; //0: not in a branch, 1: in some branch (can be in more than one)
}Rdata;

typedef struct { //Thread data for multiprocessing image databases
	int N;
	long RecNum;
	int Size; //28, 18, or 16
	int Contrast;
	int rb;
	int re;
	int cb;
	int ce;
	char Type; //R, C, or D (Row, Column, or Diagonal view)
	char Results[TOTAL_ALLOWED_RESULTS+1][11]; //A blank 'view' can potentially recognize all 10 digits!
} ImageMP;

typedef struct { //Row,Column locations tracing a boundary around an image
	int point[196][196]; //196 is probably more than enough for a 28x28 MNIST image
} ImageBoundary;

typedef struct { //In-memory copy of the images from mnist_train.txt
	//Each MNIST image is a long string of text:
	//		The 1st character identifies the digit (a.k.a. "the label"): 0, 1, ..., 9
	//		The 2nd chatacter is a comma
	//		The rest of the string is 784 pixel values: 0 - 255, separated by commas
	char image[IMAGE_LENGTH+1];
} MNISTimage;

typedef struct { //A transformed MNIST image: 784 pixel string --> square array
	// The numeric pixels have been replaced by:
	//		" " = zero
	//		"n" = non-zero value
	//		"+" = zero in a space fully enclosed by "n"s.
	char image[MAX_IMAGE_SIZE+1][MAX_IMAGE_SIZE+1];
	int ImageSize; //28x28, or 18x18, or 16x16
} NDBimage;

typedef struct { //Each image processing thread has this memory for its own Ndb and image RN values
	long RecNum;
	char digit;
	int ImageRNblocks;	//Blocks of memory assigned to the list of RNs
	NdbImageRN *pImageRN;	//Memory assigned to the list of RNs discovered by the thread
	int RNcount;		//Total number of RNs
	long ONcount;		//Total number of ONs
	long ConnectCount;	//Total number of RN-ON connections
	NdbON *pON;			//Memory assigned to ONs
	NdbRNtoON *pRNtoON;	//Memory assigned to RN-ON connections
	int RWTB;			//Image Weight: Top heavy or Bottom heavy
	int RWRL;			//Image Weight: Right or Left heavy
	int LL;				//Where are the Longest Line: row, column, diagonal?
	int SLANT;			//Image shape
	int GIRTH;			//Image shape
	int LR;				//Where is the longest row:	top, middle, bottom
	int INT;			//Where are interior spaces located: upper half? lower half?
	int PED;			//Pedestal: Is the bottom half of the image top-heavy or bottom heavy?
	int CAV;			//Identify cavities in the front & back boundaries
	int CS;				//Is the image mostly straight or mostly curvy?
} ImageData;

typedef struct {	//Member of a linked list of a branch generated from the ON records in pR[] (Rdata)
	int R;			//Record# in pR[]: 1, 2, 3, ...
	int Next;		//Next ON aligned with this ON's End Boundary. If 0: end of branch
	int Prev;		//Previous ON whose End Boundary aligns with this ON's Begin Boundary
} BRdata;

typedef struct {	//Head of a linked list of a branch generated from the ON records in pR[] (Rdata)
	int First;		//Index in BRdata[] of the beginning ON in the branch
	int Last;		//Index of the ON at the current end of the branch
	int Tlength;	//Total branch length
	float TCscore;	//Total of all the Composite Scores of all the ONs in the branch
	int Deleted;	//Weak branches can be deleted at any time during the assembly of the branches
} BRHdata; 

typedef struct {	//List of the competing Branches and their competition data from the SCU
	int BR;			//Branch Record in pBR[]: 1, 2, 3, ...
	int SCUscore;
	int Eliminated; //0 or 1
	int NCcount;	//NoCompete count
	int NCblocks;	//NoCompete blocks
	int *pNC;		//NoCompete List: Branches this branch has already competed with
} Tdata;

typedef struct {	//The ON(s) making up a tournament-winning branch
	int B;			//Begin Boundary;
	int E;			//End Boundary
	long ONcode;
	char ON[INQUIRY_LENGTH+1];
	char ACT[INQUIRY_LENGTH+1];
} ONresult; 

typedef struct {	//A tournament-winning branch
	int NumberOfONs;
	ONresult Result[INQUIRY_LENGTH+1];
} RESULT;

typedef struct {	//Recognition data for this inquiry
	int BHcount;
	int BHblocks;
	BH *pBH;		//Header to the Linked list of initial Bound Sections

	long BLcount;
	int BLblocks;
	BL *pBL;		//Linked list of initial Bound Sections, identified by the RNs in the Input Stream

	int mpCcount[MAX_THREADS+1];
	int mpCblocks[MAX_THREADS+1];
	BC *mpC[MAX_THREADS+1]; //Memory for the 'combined' Bound Sections found in pB[]

	int mpDcount[MAX_THREADS+1];
	int mpDblocks[MAX_THREADS+1];
	D *mpD[MAX_THREADS+1];

	int Dcount;
	int Dblocks;
	D *pD; //Memory for the Bound Sections from pB & mpC that survived the HIT_THRESHOLD

	int Ecount;
	int Eblocks;
	E *pE; //Memory for the Bound Sections from pD that survived the ANOMALY_THRESHOLD

	int BRcount;
	int BRblocks;
	BRdata *pBR;	//Memory for ON Branch Members

	int BRHcount;
	int BRHblocks;
	BRHdata *pBRH;	//Memory for ON Branch Heads

	int Tcount;
	int Tblocks;
	Tdata *pT;		//Memory for the Tournament of Branches

	int Rcount;
	int Rblocks;
	Rdata *pR;		//Memory for Competition results

	int RESULTcount; //Total number of results to the inquiry, e.g. "NS" -> "TONS", "LENS", ...
	RESULT pRES[TOTAL_ALLOWED_RESULTS+1]; //Room for the branches of winners

	int ISRN[INQUIRY_LENGTH+1];		// Input Stream in RNs
	int Space[INQUIRY_LENGTH+1];	// The locations of possibly relevant spaces in the Input Stream
	int Owned[INQUIRY_LENGTH+1];	// Positions in the Input Stream 'owned' by powerful ONs
} RECdata;

typedef struct {	//Array of output results
	int REScount;	//Number of results;
	ONresult Result[INQUIRY_LENGTH+1];
} OUTPUT;



// Global Functions:
extern int RecognizeTEXT(NdbData *, char *);
extern int mpRecognizeIMAGE(long, char *);
extern int RunSCU(NdbData *, RECdata *, COMP *, COMP *);

extern int GetONs(NdbData *, RECdata *);
extern void LoadR(NdbData *, RECdata *, int, int, int, int);
extern int ExecuteActions(char *);

extern int CreateNdb(int, char *);
extern int CreateNdbAdditions(int, char *, char *, int, int);
extern int CreateQuestionNdb(int, char *);
extern int mpCreateImageNdbs();
extern int AddImages();

extern int GetImage(char *, int, NDBimage *, NDBimage *, NDBimage *);
extern void ImageFormatter(ImageData *, NDBimage *, int *);

extern int LoadNdb(NdbData *);
extern void FreeMem(NdbData *); //release memory allocated for the Ndb


//Global Variables
extern int ActualThreads;		//The number of logical processors detected on this system
extern char SubDirectoryNdbs[];	//Subdirectory where neural databases are stored
extern char MNISTerrors[];		//File listing the MNIST Test records that failed recognition
extern int ShowProgress;		//Used to display processing events
extern SCUswitches SCUswitch;	//Used to turn SCU agents On/Off

extern OUTPUT pOUT[];			//Results of an inquiry
extern int OUTcount;			//Number of results in pOUT
